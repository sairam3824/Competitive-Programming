# Competitive Programming setup

# Clean up old function definitions (if they exist)
unfunction A.cc B.cc C.cc D.cc E.cc F.cc 2>/dev/null

# Get the directory where this script is located
if [[ -n "$ZSH_VERSION" ]]; then
    CP_DIR="$( cd "$( dirname "${(%):-%x}" )" && pwd )"
else
    CP_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
fi

# Function to create a file from template
function cf() {
    if [ -z "$1" ]; then
        echo "Usage: cf <filename>"
        echo "Examples:"
        echo "  cf A.cc      -> creates cpp/A.cc"
        echo "  cf 342.java  -> creates java/342.java"
        echo "  cf app.py    -> creates py/app.py"
        return 1
    fi
    
    FILENAME="$1"
    
    # Determine folder based on extension
    if [[ "$FILENAME" =~ \.cc$ ]] || [[ "$FILENAME" =~ \.cpp$ ]]; then
        FOLDER="codes/cpp/src"
        TEMPLATE="$CP_DIR/templates/template.cc"
    elif [[ "$FILENAME" =~ \.java$ ]]; then
        FOLDER="codes/java"
        TEMPLATE="$CP_DIR/templates/template.java"
    elif [[ "$FILENAME" =~ \.py$ ]]; then
        FOLDER="codes/py"
        TEMPLATE="$CP_DIR/templates/template.py"
    else
        echo "Unsupported file extension. Use .cc, .cpp, .java, or .py"
        return 1
    fi
    
    TARGET="$CP_DIR/$FOLDER/$FILENAME"
    
    if [ -f "$TARGET" ]; then
        echo "File $TARGET already exists!"
        return 1
    fi
    
    # Create from template if available, otherwise create empty file
    if [ -n "$TEMPLATE" ] && [ -f "$TEMPLATE" ]; then
        BASENAME="${FILENAME%.*}"
        sed "s/PROBLEM_NAME/$BASENAME/g" "$TEMPLATE" > "$TARGET"
    else
        touch "$TARGET"
    fi
    
    echo "Created $FOLDER/$FILENAME"
}

# Function to compile and run with time and memory tracking
function cfrun() {
    if [ -z "$1" ]; then
        echo "Usage: cfrun <filename>"
        echo "Examples:"
        echo "  cfrun A.cc      -> compiles and runs cpp/A.cc with time/memory stats"
        echo "  cfrun 342.java  -> compiles and runs java/342.java with time/memory stats"
        echo "  cfrun app.py    -> runs py/app.py with time/memory stats"
        return 1
    fi
    
    FILENAME="$1"
    
    # Determine folder and compilation based on extension
    if [[ "$FILENAME" =~ \.cc$ ]] || [[ "$FILENAME" =~ \.cpp$ ]]; then
        SRC_FOLDER="codes/cpp/src"
        TEST_FOLDER="codes/cpp"
        FILEPATH="$CP_DIR/$SRC_FOLDER/$FILENAME"
        
        if [ ! -f "$FILEPATH" ]; then
            echo "File $FILEPATH does not exist!"
            return 1
        fi
        
        BASENAME="${FILENAME%.*}"
        OUTFILE="$CP_DIR/$TEST_FOLDER/$BASENAME"
        
        echo "Compiling $SRC_FOLDER/$FILENAME..."
        cd "$CP_DIR/$SRC_FOLDER"
        g++ -std=c++17 -O2 -Wall -Wextra -DDEBUG "$FILENAME" -o "$OUTFILE"
        
        if [ $? -ne 0 ]; then
            echo "Compilation failed!"
            return 1
        fi
        
        echo "Running $BASENAME..."
        echo "-------------------"
        
        cd "$CP_DIR/$TEST_FOLDER"
        
        # Read problem limits from info file
        INFO_FILE="$CP_DIR/$TEST_FOLDER/${BASENAME}.info.txt"
        TIME_LIMIT_MS=0
        MEMORY_LIMIT_MB=0
        
        if [ -f "$INFO_FILE" ]; then
            TIME_LIMIT_MS=$(grep "Time Limit:" "$INFO_FILE" | sed 's/Time Limit: //g' | sed 's/ms//g' | tr -d ' ')
            MEMORY_LIMIT_MB=$(grep "Memory Limit:" "$INFO_FILE" | sed 's/Memory Limit: //g' | sed 's/MB//g' | tr -d ' ')
        fi
        
        EXPECTED_FILE="$CP_DIR/$TEST_FOLDER/${BASENAME}-1.out"
        INPUT_FILE="$CP_DIR/$TEST_FOLDER/${BASENAME}-1.in"
        
        # Run with time and memory measurement
        if [ -f "$EXPECTED_FILE" ]; then
            echo "Expected Output:"
            cat "$EXPECTED_FILE"
            echo "-------------------"
            echo "Your Output:"
            
            if [ -f "$INPUT_FILE" ]; then
                # Timing message moved
                
                # Run with memory and time tracking
                START_TIME=$(python3 -c "import time; print(time.time())")
                
                # Run with memory monitoring (suppress job control output)
                set +m  # Disable job control
                ./"$BASENAME" < "$INPUT_FILE" > .temp_out &
                PID=$!
                MAXMEM=0
                
                # Monitor memory usage
                while kill -0 $PID 2>/dev/null; do
                    CURRENT_MEM=$(ps -o rss= -p $PID 2>/dev/null | tr -d ' ')
                    if [[ "$CURRENT_MEM" =~ ^[0-9]+$ ]] && [ "$CURRENT_MEM" -gt "$MAXMEM" ]; then
                        MAXMEM=$CURRENT_MEM
                    fi
                    sleep 0.01
                done
                wait $PID
                set -m  # Re-enable job control
                END_TIME=$(python3 -c "import time; print(time.time())")
                EXEC_TIME=$(python3 -c "print(f'{float('$END_TIME') - float('$START_TIME'):.3f}')")
                
                cat .temp_out
                echo "-------------------"
                echo "â±ï¸  Measuring execution time and memory..."
                echo "ðŸ“Š Performance Stats:"
                echo "Memory: ${MAXMEM} KB"
                echo "Time: ${EXEC_TIME} seconds"
                
                # Check limits and show warnings
                EXEC_TIME_MS=$(python3 -c "print(int(float('$EXEC_TIME') * 1000))")
                MEMORY_MB=$(python3 -c "print(round(float('$MAXMEM') / 1024, 2))")
                
                if [ "$TIME_LIMIT_MS" -gt 0 ] && [ "$EXEC_TIME_MS" -gt "$TIME_LIMIT_MS" ]; then
                    echo "âš ï¸  \033[33mWARNING: Time limit exceeded! (${EXEC_TIME_MS}ms > ${TIME_LIMIT_MS}ms)\033[0m"
                fi
                
                if [ "$MEMORY_LIMIT_MB" -gt 0 ] && [ "$(python3 -c "print(1 if $MEMORY_MB > $MEMORY_LIMIT_MB else 0)")" -eq 1 ]; then
                    echo "âš ï¸  \033[33mWARNING: Memory limit exceeded! (${MEMORY_MB}MB > ${MEMORY_LIMIT_MB}MB)\033[0m"
                fi
            else
                # Timing message moved
                
                START_TIME=$(python3 -c "import time; print(time.time())")
                
                # Run with memory monitoring (suppress job control output)
                set +m  # Disable job control
                ./"$BASENAME" > .temp_out &
                PID=$!
                MAXMEM=0
                
                # Monitor memory usage
                while kill -0 $PID 2>/dev/null; do
                    CURRENT_MEM=$(ps -o rss= -p $PID 2>/dev/null | tr -d ' ')
                    if [[ "$CURRENT_MEM" =~ ^[0-9]+$ ]] && [ "$CURRENT_MEM" -gt "$MAXMEM" ]; then
                        MAXMEM=$CURRENT_MEM
                    fi
                    sleep 0.01
                done
                wait $PID
                set -m  # Re-enable job control
                END_TIME=$(python3 -c "import time; print(time.time())")
                EXEC_TIME=$(python3 -c "print(f'{float('$END_TIME') - float('$START_TIME'):.3f}')")
                
                cat .temp_out
                echo "-------------------"
                echo "â±ï¸  Measuring execution time and memory..."
                echo "ðŸ“Š Performance Stats:"
                echo "Memory: ${MAXMEM} KB"
                echo "Time: ${EXEC_TIME} seconds"
            fi
            
            python3 -c "
import sys
try:
    with open(sys.argv[1]) as f1, open(sys.argv[2]) as f2:
        e = [l.strip() for l in f1 if l.strip()]
        o = [l.strip() for l in f2 if l.strip()]
    p = sum(1 for a,b in zip(e,o) if a==b)
    total = len(e)
    if p == total:
        print(f'-------------------\n\033[32mâœ… Test Cases Passed: {p} / {total}\033[0m')
    else:
        print(f'-------------------\n\033[31mâŒ Test Cases Passed: {p} / {total}\033[0m')
except: pass" "$EXPECTED_FILE" .temp_out
            rm .temp_out 2>/dev/null
        else
            echo "No expected output file found. Running with time/memory measurement:"
            
            START_TIME=$(python3 -c "import time; print(time.time())")
            
            if [ -f "$INPUT_FILE" ]; then
                # Run with memory monitoring
                set +m  # Disable job control
                ./"$BASENAME" < "$INPUT_FILE" &
                PID=$!
                MAXMEM=0
                
                # Monitor memory usage
                while kill -0 $PID 2>/dev/null; do
                    CURRENT_MEM=$(ps -o rss= -p $PID 2>/dev/null | tr -d ' ')
                    if [[ "$CURRENT_MEM" =~ ^[0-9]+$ ]] && [ "$CURRENT_MEM" -gt "$MAXMEM" ]; then
                        MAXMEM=$CURRENT_MEM
                    fi
                    sleep 0.01
                done
                wait $PID
                set -m  # Re-enable job control
            else
                # Run with memory monitoring
                set +m  # Disable job control
                ./"$BASENAME" &
                PID=$!
                MAXMEM=0
                
                # Monitor memory usage
                while kill -0 $PID 2>/dev/null; do
                    CURRENT_MEM=$(ps -o rss= -p $PID 2>/dev/null | tr -d ' ')
                    if [[ "$CURRENT_MEM" =~ ^[0-9]+$ ]] && [ "$CURRENT_MEM" -gt "$MAXMEM" ]; then
                        MAXMEM=$CURRENT_MEM
                    fi
                    sleep 0.01
                done
                wait $PID
                set -m  # Re-enable job control
            fi
            
            END_TIME=$(python3 -c "import time; print(time.time())")
            EXEC_TIME=$(python3 -c "print(f'{float('$END_TIME') - float('$START_TIME'):.3f}')")
            
            echo "-------------------"
            echo "â±ï¸  Measuring execution time and memory..."
            echo "ðŸ“Š Performance Stats:"
            echo "Memory: ${MAXMEM} KB"
            echo "Time: ${EXEC_TIME} seconds"
            
            # Check limits and show warnings
            EXEC_TIME_MS=$(python3 -c "print(int(float('$EXEC_TIME') * 1000))")
            MEMORY_MB=$(python3 -c "print(round(float('$MAXMEM') / 1024, 2))")
            
            if [ "$TIME_LIMIT_MS" -gt 0 ] && [ "$EXEC_TIME_MS" -gt "$TIME_LIMIT_MS" ]; then
                echo "âš ï¸  \033[33mWARNING: Time limit exceeded! (${EXEC_TIME_MS}ms > ${TIME_LIMIT_MS}ms)\033[0m"
            fi
            
            if [ "$MEMORY_LIMIT_MB" -gt 0 ] && [ "$(python3 -c "print(1 if $MEMORY_MB > $MEMORY_LIMIT_MB else 0)")" -eq 1 ]; then
                echo "âš ï¸  \033[33mWARNING: Memory limit exceeded! (${MEMORY_MB}MB > ${MEMORY_LIMIT_MB}MB)\033[0m"
            fi
        fi
        
    elif [[ "$FILENAME" =~ \.java$ ]]; then
        FOLDER="codes/java"
        FILEPATH="$CP_DIR/$FOLDER/$FILENAME"
        
        if [ ! -f "$FILEPATH" ]; then
            echo "File $FILEPATH does not exist!"
            return 1
        fi
        
        CLASSNAME="${FILENAME%.java}"
        
        echo "Compiling $FOLDER/$FILENAME..."
        cd "$CP_DIR/$FOLDER"
        javac "$FILENAME"
        
        if [ $? -ne 0 ]; then
            echo "Compilation failed!"
            return 1
        fi
        
        echo "Running $CLASSNAME..."
        echo "-------------------"
        
        EXPECTED_FILE="$CP_DIR/$FOLDER/${CLASSNAME}-1.out"
        INPUT_FILE="$CP_DIR/$FOLDER/${CLASSNAME}-1.in"
        
        if [ -f "$EXPECTED_FILE" ]; then
            echo "Expected Output:"
            cat "$EXPECTED_FILE"
            echo "-------------------"
            echo "Your Output:"
            
            if [ -f "$INPUT_FILE" ]; then
                # Timing message moved
                # Memory and time tracking for Java
                START_TIME=$(python3 -c "import time; print(time.time())")
                java "$CLASSNAME" < "$INPUT_FILE" 2>.time_stats | tee .temp_out
                echo "-------------------"
                echo "â±ï¸  Measuring execution time and memory..."
                echo "ðŸ“Š Performance Stats:"
                cat .time_stats
                rm .time_stats 2>/dev/null
            else
                # Timing message moved
                # Memory and time tracking for Java
                START_TIME=$(python3 -c "import time; print(time.time())")
                java "$CLASSNAME" 2>.time_stats | tee .temp_out
                echo "-------------------"
                echo "â±ï¸  Measuring execution time and memory..."
                echo "ðŸ“Š Performance Stats:"
                cat .time_stats
                rm .time_stats 2>/dev/null
            fi
            
            python3 -c "
import sys
try:
    with open(sys.argv[1]) as f1, open(sys.argv[2]) as f2:
        e = [l.strip() for l in f1 if l.strip()]
        o = [l.strip() for l in f2 if l.strip()]
    total = len(e)
    if p == total:
        print(f'-------------------\n\033[32mâœ… Test Cases Passed: {p} / {total}\033[0m')
    else:
        print(f'-------------------\n\033[31mâŒ Test Cases Passed: {p} / {total}\033[0m')
    print(f'-------------------\nâœ… Test Cases Passed: {p} / {len(e)}')
except: pass" "$EXPECTED_FILE" .temp_out
            rm .temp_out 2>/dev/null
        else
            echo "No expected output file found. Running with time/memory measurement:"
            if [ -f "$INPUT_FILE" ]; then
                # Memory and time tracking for Java
                START_TIME=$(python3 -c "import time; print(time.time())")
                java "$CLASSNAME" < "$INPUT_FILE"
            else
                # Memory and time tracking for Java
                START_TIME=$(python3 -c "import time; print(time.time())")
                java "$CLASSNAME"
            fi
        fi
        
    elif [[ "$FILENAME" =~ \.py$ ]]; then
        FOLDER="codes/py"
        FILEPATH="$CP_DIR/$FOLDER/$FILENAME"
        
        if [ ! -f "$FILEPATH" ]; then
            echo "File $FILEPATH does not exist!"
            return 1
        fi
        
        echo "Running $FOLDER/$FILENAME..."
        echo "-------------------"
        
        BASENAME="${FILENAME%.py}"
        EXPECTED_FILE="$CP_DIR/$FOLDER/${BASENAME}-1.out"
        INPUT_FILE="$CP_DIR/$FOLDER/${BASENAME}-1.in"
        
        if [ -f "$EXPECTED_FILE" ]; then
            echo "Expected Output:"
            cat "$EXPECTED_FILE"
            echo "-------------------"
            echo "Your Output:"
            
            cd "$CP_DIR/$FOLDER"
            if [ -f "$INPUT_FILE" ]; then
                # Timing message moved
                # Memory and time tracking for Python
                START_TIME=$(python3 -c "import time; print(time.time())")
                python3 "$FILENAME" < "$INPUT_FILE" 2>.time_stats | tee .temp_out
                echo "-------------------"
                echo "â±ï¸  Measuring execution time and memory..."
                echo "ðŸ“Š Performance Stats:"
                cat .time_stats
                rm .time_stats 2>/dev/null
            else
                # Timing message moved
                # Memory and time tracking for Python
                START_TIME=$(python3 -c "import time; print(time.time())")
                python3 "$FILENAME" 2>.time_stats | tee .temp_out
                echo "-------------------"
                echo "â±ï¸  Measuring execution time and memory..."
                echo "ðŸ“Š Performance Stats:"
                cat .time_stats
                rm .time_stats 2>/dev/null
            fi
            
            python3 -c "
import sys
try:
    with open(sys.argv[1]) as f1, open(sys.argv[2]) as f2:
        e = [l.strip() for l in f1 if l.strip()]
    total = len(e)
    if p == total:
        print(f'-------------------\n\033[32mâœ… Test Cases Passed: {p} / {total}\033[0m')
    else:
        print(f'-------------------\n\033[31mâŒ Test Cases Passed: {p} / {total}\033[0m')
    p = sum(1 for a,b in zip(e,o) if a==b)
    print(f'-------------------\nâœ… Test Cases Passed: {p} / {len(e)}')
except: pass" "$EXPECTED_FILE" .temp_out
            rm .temp_out 2>/dev/null
        else
            echo "No expected output file found. Running with time/memory measurement:"
            cd "$CP_DIR/$FOLDER"
            if [ -f "$INPUT_FILE" ]; then
                # Memory and time tracking for Python
                START_TIME=$(python3 -c "import time; print(time.time())")
                python3 "$FILENAME" < "$INPUT_FILE"
            else
                # Memory and time tracking for Python
                START_TIME=$(python3 -c "import time; print(time.time())")
                python3 "$FILENAME"
            fi
        fi
        
    else
        echo "Unsupported file extension. Use .cc, .cpp, .java, or .py"
        return 1
    fi
}

# Alias for convenience

# Start Competitive Companion listener
function cflisten() {
    echo "Starting Competitive Companion listener..."
    cd "$CP_DIR"
    node listener.js
}
alias run="cfrun"

# Quick alias for running code
alias run=cfrun
